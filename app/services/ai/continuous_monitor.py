"""
Continuous AI Monitoring Service
==================================
Background service that continuously monitors plant conditions and provides
real-time insights, predictions, and proactive alerts.

Features:
- Real-time condition analysis every 5-15 minutes
- Proactive issue detection (before problems become visible)
- Trend analysis and forecasting
- Automated recommendations
- Integration with all AI services
"""

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable, TYPE_CHECKING
from dataclasses import dataclass
from enum import Enum

if TYPE_CHECKING:
    from app.services.ai.disease_predictor import DiseasePredictor
    from app.services.ai.climate_optimizer import ClimateOptimizer
    from app.services.ai.plant_health_monitor import PlantHealthMonitor
    from app.services.ai.plant_growth_predictor import PlantGrowthPredictor
    from app.services.ai.environmental_health_scorer import EnvironmentalLeafHealthScorer
    from app.services.ai.recommendation_provider import RecommendationProvider, RecommendationContext
    from infrastructure.database.repositories.analytics import AnalyticsRepository
    from app.services.application.notifications_service import NotificationsService

logger = logging.getLogger(__name__)


class AlertLevel(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class GrowingInsight:
    """A growing insight generated by continuous monitoring."""
    
    unit_id: int
    insight_type: str  # 'prediction', 'alert', 'recommendation', 'trend'
    alert_level: AlertLevel
    title: str
    description: str
    data: Dict[str, Any]
    action_items: List[str]
    timestamp: datetime
    expires_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "unit_id": self.unit_id,
            "insight_type": self.insight_type,
            "alert_level": self.alert_level.value,
            "title": self.title,
            "description": self.description,
            "data": self.data,
            "action_items": self.action_items,
            "timestamp": self.timestamp.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
        }


class ContinuousMonitoringService:
    """
    Continuous monitoring service for proactive plant care.
    
    Runs in background thread, analyzing conditions every 5-15 minutes
    and generating real-time insights, predictions, and alerts.
    """
    
    def __init__(
        self,
        disease_predictor: "DiseasePredictor",
        climate_optimizer: "ClimateOptimizer",
        health_monitor: "PlantHealthMonitor",
        growth_predictor: "PlantGrowthPredictor",
        analytics_repo: "AnalyticsRepository",
        check_interval: int = 300,  # 5 minutes default
        environmental_health_scorer: Optional["EnvironmentalLeafHealthScorer"] = None,
        recommendation_provider: Optional["RecommendationProvider"] = None,
    ):
        """
        Initialize continuous monitoring service.
        
        Args:
            disease_predictor: Disease prediction service
            climate_optimizer: Climate optimization service
            health_monitor: Plant health monitoring service
            growth_predictor: Growth prediction service
            analytics_repo: Analytics repository for data access
            check_interval: Seconds between monitoring checks
            environmental_health_scorer: Optional env leaf-health scorer
            recommendation_provider: Optional recommendation provider
        """
        self.disease_predictor = disease_predictor
        self.climate_optimizer = climate_optimizer
        self.health_monitor = health_monitor
        self.growth_predictor = growth_predictor
        self.analytics_repo = analytics_repo
        self.check_interval = check_interval
        self.environmental_health_scorer = environmental_health_scorer
        self.recommendation_provider = recommendation_provider
        
        # State management
        self._monitoring_thread: Optional[threading.Thread] = None
        self._running = False
        self._monitored_units: List[int] = []
        
        # Insight storage (recent insights per unit)
        self._insights: Dict[int, List[GrowingInsight]] = {}
        self._max_insights_per_unit = 50
        
        # Callbacks for external notification systems
        self._on_critical_alert: Optional[Callable[[GrowingInsight], None]] = None
        self._on_new_insight: Optional[Callable[[GrowingInsight], None]] = None
        
        # Notification service integration
        self._notifications_service: Optional["NotificationsService"] = None
        self._user_resolver: Optional[Callable[[int], Optional[int]]] = None
        
        logger.info("ContinuousMonitoringService initialized")
    
    def start_monitoring(self, unit_ids: Optional[List[int]] = None):
        """
        Start continuous monitoring for specified units.
        
        Args:
            unit_ids: List of unit IDs to monitor (None = all units)
        """
        if self._running:
            logger.warning("Monitoring already running")
            return
        
        self._running = True
        
        # Get units to monitor
        if unit_ids:
            self._monitored_units = unit_ids
        else:
            # Get all active units from database
            self._monitored_units = self._get_all_active_units()
        
        # Start monitoring thread
        self._monitoring_thread = threading.Thread(
            target=self._monitoring_loop,
            daemon=True,
            name="ContinuousMonitoring"
        )
        self._monitoring_thread.start()
        
        logger.info(f"Started monitoring {len(self._monitored_units)} units")
    
    def stop_monitoring(self):
        """Stop continuous monitoring."""
        if not self._running:
            return
        
        self._running = False
        if self._monitoring_thread:
            self._monitoring_thread.join(timeout=10)
        
        logger.info("Stopped continuous monitoring")
    
    def add_unit(self, unit_id: int):
        """Add a unit to monitoring."""
        if unit_id not in self._monitored_units:
            self._monitored_units.append(unit_id)
            logger.info(f"Added unit {unit_id} to monitoring")
    
    def remove_unit(self, unit_id: int):
        """Remove a unit from monitoring."""
        if unit_id in self._monitored_units:
            self._monitored_units.remove(unit_id)
            logger.info(f"Removed unit {unit_id} from monitoring")
    
    def get_insights(
        self,
        unit_id: int,
        limit: int = 10,
        min_level: Optional[AlertLevel] = None
    ) -> List[GrowingInsight]:
        """
        Get recent insights for a unit.
        
        Args:
            unit_id: Unit ID
            limit: Maximum number of insights to return
            min_level: Minimum alert level to include
            
        Returns:
            List of insights
        """
        insights = self._insights.get(unit_id, [])
        
        # Filter by alert level if specified
        if min_level:
            level_priority = {
                AlertLevel.INFO: 0,
                AlertLevel.WARNING: 1,
                AlertLevel.CRITICAL: 2
            }
            min_priority = level_priority[min_level]
            insights = [
                i for i in insights
                if level_priority[i.alert_level] >= min_priority
            ]
        
        # Return most recent
        return sorted(insights, key=lambda x: x.timestamp, reverse=True)[:limit]
    
    def _monitoring_loop(self):
        """Main monitoring loop."""
        logger.info("Monitoring loop started")
        
        while self._running:
            try:
                start_time = time.time()
                
                # Monitor each unit
                for unit_id in self._monitored_units:
                    try:
                        self._monitor_unit(unit_id)
                    except Exception as e:
                        logger.error(f"Error monitoring unit {unit_id}: {e}", exc_info=True)
                
                # Calculate sleep time to maintain interval
                elapsed = time.time() - start_time
                sleep_time = max(0, self.check_interval - elapsed)
                
                if sleep_time > 0:
                    time.sleep(sleep_time)
                    
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}", exc_info=True)
                time.sleep(60)  # Wait before retrying
    
    def _monitor_unit(self, unit_id: int):
        """Monitor a single unit and generate insights."""
        
        # Get unit metadata
        unit_metadata = self._get_unit_metadata(unit_id)
        if not unit_metadata:
            logger.warning(f"No metadata for unit {unit_id}")
            return
        
        plant_type = unit_metadata.get('plant_type')
        growth_stage = unit_metadata.get('growth_stage')
        
        # Get current sensor readings
        current_conditions = self._get_current_conditions(unit_id)
        if not current_conditions:
            logger.warning(f"No sensor data for unit {unit_id}")
            return
        
        # Run all AI analyses
        insights = []
        
        # 1. Disease Risk Analysis
        disease_insights = self._analyze_disease_risk(
            unit_id, plant_type, growth_stage, current_conditions
        )
        insights.extend(disease_insights)
        
        # 2. Climate Optimization
        climate_insights = self._analyze_climate_optimization(
            unit_id, growth_stage, current_conditions, plant_type=plant_type
        )
        insights.extend(climate_insights)
        
        # 3. Growth Progress
        growth_insights = self._analyze_growth_progress(
            unit_id, plant_type, growth_stage, current_conditions
        )
        insights.extend(growth_insights)
        
        # 4. Trend Analysis
        trend_insights = self._analyze_trends(unit_id, current_conditions)
        insights.extend(trend_insights)
        
        # 5. Environmental Health Scoring
        env_health_insights = self._analyze_environmental_health(
            unit_id, plant_type, growth_stage, current_conditions
        )
        insights.extend(env_health_insights)
        
        # 6. Consolidated Recommendations
        rec_insights = self._analyze_recommendations(
            unit_id, plant_type, growth_stage, current_conditions
        )
        insights.extend(rec_insights)
        
        # Store insights
        if unit_id not in self._insights:
            self._insights[unit_id] = []
        
        self._insights[unit_id].extend(insights)
        
        # Trim to max size
        self._insights[unit_id] = self._insights[unit_id][-self._max_insights_per_unit:]
        
        # Trigger callbacks
        for insight in insights:
            if insight.alert_level == AlertLevel.CRITICAL and self._on_critical_alert:
                self._on_critical_alert(insight)
            if self._on_new_insight:
                self._on_new_insight(insight)
    
    def _analyze_disease_risk(
        self,
        unit_id: int,
        plant_type: str,
        growth_stage: str,
        current_conditions: Dict[str, float]
    ) -> List[GrowingInsight]:
        """Analyze disease risk and generate insights."""
        insights = []
        
        try:
            # Get disease predictions
            risks = self.disease_predictor.predict_disease_risk(
                unit_id=unit_id,
                plant_type=plant_type,
                growth_stage=growth_stage,
                current_conditions=current_conditions
            )
            
            # Create insights for high-risk diseases
            for risk in risks:
                if risk.risk_level.value in ['high', 'critical']:
                    alert_level = (
                        AlertLevel.CRITICAL if risk.risk_level.value == 'critical'
                        else AlertLevel.WARNING
                    )
                    
                    insight = GrowingInsight(
                        unit_id=unit_id,
                        insight_type='alert',
                        alert_level=alert_level,
                        title=f"{risk.disease_type.value.title()} Risk Detected",
                        description=f"Risk level: {risk.risk_level.value.upper()}. " + 
                                  f"Risk score: {risk.risk_score:.1f}/100",
                        data=risk.to_dict(),
                        action_items=risk.recommendations,
                        timestamp=datetime.now(),
                        expires_at=datetime.now() + timedelta(hours=24)
                    )
                    insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error analyzing disease risk: {e}", exc_info=True)
        
        return insights
    
    def _analyze_climate_optimization(
        self,
        unit_id: int,
        growth_stage: str,
        current_conditions: Dict[str, float],
        *,
        plant_type: Optional[str] = None,
    ) -> List[GrowingInsight]:
        """Analyze climate and generate optimization insights."""
        insights = []
        
        try:
            # Get climate recommendations
            recommendations = self.climate_optimizer.get_recommendations(unit_id)
            
            if recommendations['priority'] in ['high', 'critical']:
                alert_level = (
                    AlertLevel.CRITICAL if recommendations['priority'] == 'critical'
                    else AlertLevel.WARNING
                )
                
                insight = GrowingInsight(
                    unit_id=unit_id,
                    insight_type='recommendation',
                    alert_level=alert_level,
                    title="Climate Adjustment Needed",
                    description=f"Priority: {recommendations['priority'].upper()}",
                    data=recommendations,
                    action_items=recommendations['actions'],
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=12)
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error analyzing climate: {e}", exc_info=True)
        
        return insights
    
    def _analyze_growth_progress(
        self,
        unit_id: int,
        plant_type: str,
        growth_stage: str,
        current_conditions: Dict[str, float]
    ) -> List[GrowingInsight]:
        """Analyze growth progress and generate insights."""
        insights = []
        
        try:
            # Get days in current stage
            days_in_stage = self._get_days_in_stage(unit_id)
            
            # Check stage transition readiness
            transition = self.growth_predictor.analyze_stage_transition(
                current_stage=growth_stage,
                days_in_stage=days_in_stage,
                actual_conditions=current_conditions
            )
            
            if transition.ready:
                insight = GrowingInsight(
                    unit_id=unit_id,
                    insight_type='prediction',
                    alert_level=AlertLevel.INFO,
                    title="Ready for Next Growth Stage",
                    description=f"Plant is ready to transition from {transition.from_stage} " +
                              f"to {transition.to_stage} stage",
                    data=transition.to_dict(),
                    action_items=transition.recommendations,
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(days=7)
                )
                insights.append(insight)
            elif not all(transition.conditions_met.values()):
                # Conditions not yet met
                insight = GrowingInsight(
                    unit_id=unit_id,
                    insight_type='recommendation',
                    alert_level=AlertLevel.INFO,
                    title="Growth Stage Progress",
                    description=f"Working towards {transition.to_stage} stage",
                    data=transition.to_dict(),
                    action_items=transition.recommendations,
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(days=1)
                )
                insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error analyzing growth progress: {e}", exc_info=True)
        
        return insights
    
    def _analyze_trends(
        self,
        unit_id: int,
        current_conditions: Dict[str, float]
    ) -> List[GrowingInsight]:
        """Analyze environmental trends and generate insights."""
        insights = []
        
        try:
            # Get 48-hour historical data
            historical = self._get_historical_conditions(unit_id, hours=48)
            if not historical:
                return insights
            
            # Analyze trends for each metric
            for metric in ['temperature', 'humidity', 'soil_moisture']:
                if metric not in historical or metric not in current_conditions:
                    continue
                
                values = historical[metric]
                if len(values) < 10:
                    continue
                
                # Calculate trend (linear regression slope)
                import numpy as np
                x = np.arange(len(values))
                slope, _ = np.polyfit(x, values, 1)
                
                # Check for significant trends
                current = current_conditions[metric]
                trend_threshold = {
                    'temperature': 0.5,  # 0.5Â°C per 48h
                    'humidity': 5.0,     # 5% per 48h
                    'soil_moisture': 5.0  # 5% per 48h
                }
                
                if abs(slope * len(values)) > trend_threshold[metric]:
                    direction = "increasing" if slope > 0 else "decreasing"
                    
                    insight = GrowingInsight(
                        unit_id=unit_id,
                        insight_type='trend',
                        alert_level=AlertLevel.INFO,
                        title=f"{metric.replace('_', ' ').title()} Trend Detected",
                        description=f"{metric.replace('_', ' ').title()} is {direction} " +
                                  f"(current: {current:.1f})",
                        data={
                            'metric': metric,
                            'current_value': current,
                            'trend': direction,
                            'slope': slope,
                            'historical_values': values[-24:]  # Last 24 readings
                        },
                        action_items=[
                            f"Monitor {metric} closely over next 24 hours",
                            f"Consider adjusting controls if trend continues"
                        ],
                        timestamp=datetime.now(),
                        expires_at=datetime.now() + timedelta(hours=24)
                    )
                    insights.append(insight)
        
        except Exception as e:
            logger.error(f"Error analyzing trends: {e}", exc_info=True)
        
        return insights
    
    def _get_all_active_units(self) -> List[int]:
        """Get all active growth units."""
        try:
            # Defensive: analytics_repo may not be configured
            if not hasattr(self, 'analytics_repo') or self.analytics_repo is None:
                logger.warning("Analytics repository not configured; no active units available")
                return []

            # Query database for active units
            units = self.analytics_repo.get_active_units()
            return [unit['unit_id'] for unit in units]
        except Exception as e:
            logger.error(f"Error getting active units: {e}", exc_info=True)
            return []
    
    def _get_unit_metadata(self, unit_id: int) -> Optional[Dict[str, Any]]:
        """Get unit metadata including plant type and growth stage."""
        try:
            return self.analytics_repo.get_unit_metadata(unit_id)
        except Exception as e:
            logger.error(f"Error getting unit metadata: {e}")
            return None
    
    def _get_current_conditions(self, unit_id: int) -> Optional[Dict[str, float]]:
        """Get current sensor readings."""
        try:
            #TODO: Can get the last reading without have to fetch the DB, the.
            latest = self.analytics_repo.get_latest_sensor_readings(unit_id)
            return latest if latest else None
        except Exception as e:
            logger.error(f"Error getting current conditions: {e}")
            return None
    
    def _get_historical_conditions(
        self,
        unit_id: int,
        hours: int = 48
    ) -> Dict[str, List[float]]:
        """Get historical sensor readings."""
        try:
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=hours)
            
            data = self.analytics_repo.get_sensor_time_series(
                unit_id,
                start_time.isoformat(),
                end_time.isoformat(),
                interval_hours=1
            )
            
            return {
                'temperature': data['temperature'].tolist() if 'temperature' in data else [],
                'humidity': data['humidity'].tolist() if 'humidity' in data else [],
                'soil_moisture': data['soil_moisture'].tolist() if 'soil_moisture' in data else [],
            }
        except Exception as e:
            logger.error(f"Error getting historical conditions: {e}")
            return {}
    
    def _get_days_in_stage(self, unit_id: int) -> int:
        """Get number of days plant has been in current growth stage."""
        try:
            metadata = self._get_unit_metadata(unit_id)
            if not metadata or 'stage_changed_at' not in metadata:
                return 0
            
            stage_start = datetime.fromisoformat(metadata['stage_changed_at'])
            days = (datetime.now() - stage_start).days
            return max(0, days)
        except Exception as e:
            logger.error(f"Error getting days in stage: {e}")
            return 0
    
    def set_callbacks(
        self,
        on_critical_alert: Optional[Callable[[GrowingInsight], None]] = None,
        on_new_insight: Optional[Callable[[GrowingInsight], None]] = None
    ):
        """Set callback functions for events."""
        self._on_critical_alert = on_critical_alert
        self._on_new_insight = on_new_insight
    
    def set_notification_service(
        self,
        notifications_service: "NotificationsService",
        user_resolver: Callable[[int], Optional[int]]
    ) -> None:
        """
        Wire up notifications service for alert delivery.
        
        Args:
            notifications_service: The notifications service instance
            user_resolver: Function to get user_id from unit_id
        """
        self._notifications_service = notifications_service
        self._user_resolver = user_resolver
        
        # Set callbacks to use notification service
        self._on_critical_alert = self._send_critical_notification
        self._on_new_insight = self._send_insight_notification
        
        logger.info("ContinuousMonitoringService wired to NotificationsService")
    
    def _send_critical_notification(self, insight: GrowingInsight) -> None:
        """Send critical alert as push notification."""
        if not self._notifications_service or not self._user_resolver:
            return
        
        user_id = self._user_resolver(insight.unit_id)
        if not user_id:
            logger.debug(f"No user found for unit {insight.unit_id}, skipping notification")
            return
        
        try:
            self._notifications_service.send_notification(
                user_id=user_id,
                notification_type="plant_health_warning",
                title=f"ðŸš¨ {insight.title}",
                message=insight.description,
                severity="critical",
                source_type="ai_monitor",
                unit_id=insight.unit_id,
                requires_action=True,
                action_type="view_insight",
                action_data={"insight_type": insight.insight_type, "data": insight.data}
            )
            logger.info(f"Sent critical notification for unit {insight.unit_id}: {insight.title}")
        except Exception as e:
            logger.error(f"Failed to send critical notification: {e}", exc_info=True)
    
    def _send_insight_notification(self, insight: GrowingInsight) -> None:
        """Send non-critical insights (respects throttling)."""
        if not self._notifications_service or not self._user_resolver:
            return
        
        # Only notify for warnings and above (skip INFO)
        if insight.alert_level == AlertLevel.INFO:
            return
        
        user_id = self._user_resolver(insight.unit_id)
        if not user_id:
            logger.debug(f"No user found for unit {insight.unit_id}, skipping notification")
            return
        
        severity = "warning" if insight.alert_level == AlertLevel.WARNING else "info"
        
        try:
            self._notifications_service.send_notification(
                user_id=user_id,
                notification_type="plant_health_warning",
                title=insight.title,
                message=insight.description,
                severity=severity,
                source_type="ai_monitor",
                unit_id=insight.unit_id,
                requires_action=len(insight.action_items) > 0,
                action_type="view_insight" if insight.action_items else None,
                action_data={"insight_type": insight.insight_type, "data": insight.data} if insight.data else None
            )
            logger.debug(f"Sent insight notification for unit {insight.unit_id}: {insight.title}")
        except Exception as e:
            logger.error(f"Failed to send insight notification: {e}", exc_info=True)
    
    # ------------------------------------------------------------------
    # A8 â€” additional analysis steps
    # ------------------------------------------------------------------

    def _analyze_environmental_health(
        self,
        unit_id: int,
        plant_type: Optional[str],
        growth_stage: Optional[str],
        current_conditions: Dict[str, float],
    ) -> List[GrowingInsight]:
        """Score environmental leaf-health if scorer is available."""
        if not self.environmental_health_scorer:
            return []

        insights: List[GrowingInsight] = []
        try:
            score = self.environmental_health_scorer.score_current_health(
                sensor_data=current_conditions,
                plant_type=plant_type,
                growth_stage=growth_stage,
            )
            if score and score.overall_score < 60:
                alert_level = (
                    AlertLevel.CRITICAL if score.overall_score < 30
                    else AlertLevel.WARNING
                )
                insights.append(GrowingInsight(
                    unit_id=unit_id,
                    insight_type="alert",
                    alert_level=alert_level,
                    title="Environmental Health Concern",
                    description=(
                        f"Leaf-health score is {score.overall_score:.0f}/100. "
                        f"Stress score: {score.stress_score:.0f}/100."
                    ),
                    data=score.to_dict() if hasattr(score, "to_dict") else {},
                    action_items=score.recommendations if hasattr(score, "recommendations") else [],
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=12),
                ))
        except Exception as e:
            logger.error(f"Error scoring environmental health: {e}", exc_info=True)
        return insights

    def _analyze_recommendations(
        self,
        unit_id: int,
        plant_type: Optional[str],
        growth_stage: Optional[str],
        current_conditions: Dict[str, float],
    ) -> List[GrowingInsight]:
        """Generate consolidated recommendations if provider is available."""
        if not self.recommendation_provider:
            return []

        insights: List[GrowingInsight] = []
        try:
            from app.services.ai.recommendation_provider import RecommendationContext

            context = RecommendationContext(
                plant_id=0,
                unit_id=unit_id,
                plant_type=plant_type,
                growth_stage=growth_stage,
                environmental_data=current_conditions,
            )
            recs = self.recommendation_provider.get_recommendations(context)
            urgent = [r for r in recs if r.priority in ("urgent", "high")]
            if urgent:
                actions = [r.action for r in urgent]
                insights.append(GrowingInsight(
                    unit_id=unit_id,
                    insight_type="recommendation",
                    alert_level=AlertLevel.WARNING,
                    title="Care Recommendations",
                    description=f"{len(urgent)} high-priority recommendation(s) generated.",
                    data={"recommendations": [r.to_dict() for r in urgent]},
                    action_items=actions,
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=12),
                ))
        except Exception as e:
            logger.error(f"Error generating recommendations: {e}", exc_info=True)
        return insights

    def get_status(self) -> Dict[str, Any]:
        """Get monitoring service status."""
        return {
            'running': self._running,
            'monitored_units': len(self._monitored_units),
            'check_interval_seconds': self.check_interval,
            'total_insights': sum(len(insights) for insights in self._insights.values()),
            'units_with_insights': len(self._insights),
        }
